#!/usr/bin/env ruby

def require_color_echo
    require "color_echo"
    #require_relative "../lib/color_echo"
end

def require_color_echo_get
    require "color_echo/get"
    #require_relative "../lib/color_echo/get"
end

require_relative "./lib/display"

def output_interactive
    output_stripe_interactive if @is_stripe

    while input = STDIN.gets
        input.chomp!
        exit 0 if @exit_words.index(input)
        eval(@code_decorate)
        puts CE.get(input)
    end
end

def output_stripe_interactive
    cnt = 0
    while input = STDIN.gets
        input.chomp!
        exit 0 if @exit_words.index(input)
        eval(@code_decorate) if cnt % 2 == 0
        puts CE.get(input)
        cnt += 1
    end
end

def output(target)
    output_stripe(target) if @is_stripe

    eval(@code_decorate)
    begin
        print CE.get(target)
    rescue Errno::EPIPE
    end
    exit 0
end

def output_stripe(target)
    cnt = 0
    target.split($/).each do |record|
        eval(@code_decorate) if cnt % 2 == 0
        puts CE.get(record)
        cnt += 1
    end
    exit 0
end

def parse_options
    @fg = nil
    @bg = nil
    @tx = nil
    @pickups   = []
    @is_watch  = false
    @last_lb   = true
    @enable_lf = false
    @is_stripe = false

    require "optparse"
    opt = OptionParser.new

    opt.on("-h") { usage }
    opt.on("-v") { version }
    opt.on("-s", "--symbol-list")    { display_symbol_list }
    opt.on("-l", "--index-list")     { display_color_index }
    opt.on("--symbol_list")          { display_symbol_list }  # for compatibility
    opt.on("--index_list")           { display_color_index }  # for compatibility
    opt.on("--fg val", "-f val")     { |val| @fg = val }
    opt.on("--bg val", "-b val")     { |val| @bg = val }
    opt.on("--tx val", "-t val")     { |val| @tx = val }
    opt.on("--pickup val", "-p val") { |val| @pickups << val }
    opt.on("-w", "--watch")          { @is_watch  = true }
    opt.on("-n")                     { @last_lb   = false }
    opt.on("-e")                     { @enable_lf = true }
    opt.on("--stripe")               { @is_stripe = true }

    begin
        opt.parse!(ARGV)

    rescue => err
        warn "Parse Error! Please check usage!" + $/ + $/
        usage
    end

    @fg = "yellow" if @fg == nil && @bg == nil && @tx == nil
    @fg = @fg.intern if @fg != nil
    @bg = @bg.intern if @bg != nil

    if @tx != nil
        res = []
        @tx.split(",").each do |val|
            res << val.intern
        end
        @tx = res
    end

    # ignore --pickup option when specified --stripe option
    if @pickups.size > 0 && @is_stripe
        warn "pickup option is ignored because your specified --stripe option."
        @pickups = []
    end

    # parse pickups
    if @pickups.size > 0
        code_pickup = ""
        @pickups.each_index do |index|
            if @pickups[index][0] == "/" && (@pickups[index][-1] == "/" || @pickups[index][-2] == "/")
                @pickups[index] = eval(@pickups[index])
            end

            code_pickup += %(.pickup(@pickups[#{index}], @fg, @bg, @tx))
        end
        @code_decorate = "CE" + code_pickup
    else
        @code_decorate = %(CE.ch(@fg, @bg, @tx))
    end
end

has_stdin = select([STDIN], [], [], 0) != nil || FileTest.pipe?(STDIN)
usage if !has_stdin && ARGV.size == 0

# parse options and set the decorate code that execute by eval
parse_options

require_color_echo_get
if @is_watch
    # Interactive mode
    @exit_words = ["quit", "exit", "bye"]
    output_interactive
else
    if has_stdin
        target = STDIN.read

        if ARGV.size > 0
            print target
            argv = ARGV.join(" ")
            argv += $/ if @last_lb
            output(argv)
        end
    else
        target = ARGV.join(" ")
        target += $/ if @last_lb
    end

    if @enable_lf
        target.gsub!("\\r\\n", $/)
        target.gsub!("\\n", $/)
        target.gsub!("\\r", $/)
    end

    output(target)
end
