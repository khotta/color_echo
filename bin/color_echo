#!/usr/bin/env ruby
require "color_echo"
#require_relative "../lib/color_echo.rb"

def usage
    CE.once.ch :yellow
    puts <<-EOS
    #{CE::LIBS_NAME} - #{CE::SUMMARY}
    VERSION: #{CE::VERSION}
    README: #{CE::DOCS_PAGE}

    EOS

    padding    = " " * 4
    headers    = ["* Usage", "* Options"]
    headers_op = ["-v:", "--symbol_list, -s", "--index_list, -l"]
    CE.pickup(headers, :cyan)
    CE.pickup(headers_op, :h_green)

    puts padding + "* Usage"

    CE.once.ch :h_blue
    puts padding * 2 + "color_echo [-h] [options]" + $/ + $/

    puts padding + "* Options"

    puts padding + "-v:"
    puts padding * 2 + "Display version of color_echo." + $/ + $/

    puts padding + "--symbol_list, -s"
    puts padding * 2 + "Display symbol list that can to specify." + $/ + $/ 
    
    puts padding + "--index_list, -l"
    puts padding * 2 + "Display color index list that can to specify." + $/ + $/

    exit 0
end

def display_color_index
    CE.rainbow
    cnt     = 134
    padding = " " * 2
    mes     = "OK, Let me check color index list... :)"
    puts padding + "-" * cnt
    puts padding + " " * ((cnt - mes.size)/2) + mes
    puts padding + "-" * cnt

    print padding
    256.times do |i|
        num = i + 1
        CE.fg "index#{num}".intern
        print "index#{num}" + " " * (4 - num.to_s.size)
        CE.bg "index#{num}".intern
        print " " * 5
        CE.off
        print " " * 3

        if num % 8 == 0
            print $/ + $/
            print padding if num != 256
        end
    end
    CE.off

    exit 0
end

def display_symbol_list
    symbols_color = [
        :black,
        :gray,
        :red,
        :h_red,
        :green,
        :h_green,
        :yellow,
        :h_yellow,
        :blue,
        :h_blue,
        :magenta,
        :h_magenta,
        :cyan,
        :h_cyan,
        :white,
        :h_white
    ]
    symbols_text_attr = [
        :bold,
        :underscore,
        :blink,
        :reverse_video,
        :concealed
    ]

    CE.times(3).rainbow
    cnt     = 60
    padding = " " * 2
    mes     = "OK, Let me check color name list... :)"
    puts padding + "-" * cnt
    puts padding + " " * ((cnt - mes.size)/2) + mes
    puts padding + "-" * cnt

    header_colors     = "* foreground or background colors"
    header_text_attrs = "* text attributes"
    CE.pickup([header_colors, header_text_attrs], :cyan, nil, [:underscore, :bold])

    puts padding + header_colors
    symbols_color.each do |color_name|
        CE.off(:bg).fg color_name
        print "#{padding*2}:#{color_name}" + " " * (11 - color_name.to_s.size)
        CE.bg color_name
        puts color_name.to_s + " " * (30 - color_name.to_s.size)
    end

    CE.off [:bg, :fg]
    print $/ + $/

    puts padding + header_text_attrs
    symbols_text_attr.each do |tx_name|
        CE.off(:tx).tx tx_name
        puts "#{padding*2}:#{tx_name}" + " " * (30 - tx_name.to_s.size)
    end

    print $/

    exit 0
end

usage if ARGV.size != 1

require "optparse"
opt = OptionParser.new

opt.on("-h") { usage }
opt.on("-v") { puts CE::VERSION; exit 0 }
opt.on("-s", "--symbol_list") { display_symbol_list }
opt.on("-l", "--index_list") { display_color_index }

begin
    opt.parse!(ARGV)

rescue OptionParser::InvalidOption => err
    mess = "[OPTION ERROR] Invalid option ->"
    err.args.each do |op|
        mess += %( '#{op}')
    end
    mess += " (OptionParser::InvalidOption)"
    warn mess + $/ + $/

    usage
end
