#!/usr/bin/env ruby
require_relative "./lib/display"
def dump(target)
    require "pp"
    require "stringio"

    File.open("/tmp/ruby.log", "a+") do |f|
        $stdout = StringIO.new
        pp target
        strio = $stdout
        $stdout = STDOUT
        f.print strio.string
    end
end

#
# Load color_echo
# @return void
#
def require_color_echo
    require "color_echo"
    #require_relative "../lib/color_echo"
end

#
# Load color_echo/get
# @return void
#
def require_color_echo_get
    require "color_echo/get"
    #require_relative "../lib/color_echo/get"
end

#
# output in interactive
# @return void
#
def output_interactive
    output_stripe_interactive if @is_stripe

    begin
        while input = STDIN.gets
            input.chomp!
            exit 0 if @exit_words.index(input)
            eval(@code_decorate)
            $stdout.flush.puts CE.get(input)
        end
    rescue Interrupt
        exit 1
    end
end

#
# output like stripe in interactive
# @return void
#
def output_stripe_interactive
    cnt = 0
    begin
        while input = STDIN.gets
            input.chomp!
            exit 0 if @exit_words.index(input)
            eval(@code_decorate) if cnt % 2 == 0
            puts CE.get(input)
            cnt += 1
        end
    rescue Interrupt
        exit 1
    end
end

#
# output
# @return void
#
def output(target)
    output_stripe(target) if @is_stripe

    eval(@code_decorate)
    begin
        print CE.get(target)
    rescue Errno::EPIPE
    end
    exit 0
end

#
# output like stripe
# @return void
#
def output_stripe(target)
    cnt = 0
    target.split($/).each do |record|
        eval(@code_decorate) if cnt % 2 == 0
        puts CE.get(record)
        cnt += 1
    end
    exit 0
end

#
# parse the options
# @return void
#
def parse_options
    @fg           = nil
    @bg           = nil
    @tx           = nil
    @highlight    = nil
    @pickups      = []
    @is_watch     = false
    @last_lb      = true
    @enable_lf    = false
    @is_stripe    = false
    @enable_clean = false

    begin
        @opt.parse!(ARGV)

    rescue => err
        warn %(Parse Error! Please check usage!) + $/ + $/
        puts @opt.help
        warn $/ + %(Do you want to read example to use?)
        warn %(  -> Please execute: 'colorecho -h')
    end

    @fg = "yellow" if @fg == nil && @bg == nil && @tx == nil
    @fg = @fg.intern if @fg != nil
    @bg = @bg.intern if @bg != nil

    if @tx != nil
        res = []
        @tx.split(",").each do |val|
            res << val.intern
        end
        @tx = res
    end

    # ignore --pickup option when specified --stripe option
    if @pickups.size > 0 && @is_stripe
        warn "pickup option is ignored because your specified --stripe option."
        @pickups = []
    end

    # parse pickups
    if @pickups.size > 0
        code_pickup = ""
        @pickups.each_index do |index|
            if @pickups[index][0] == "/" && (@pickups[index][-1] == "/" || @pickups[index][-2] == "/")
                @pickups[index] = eval(@pickups[index])
            end

            code_pickup += %(.pickup(@pickups[#{index}], @fg, @bg, @tx))
        end
        @code_decorate = "CE" + code_pickup

        # highlight
        if @highlight == nil
            code_highlight = %(CE.hitline(nil, nil, :bold))
        else
            params = []
            @highlight.split(",").each do |el|
                el.strip!
                if el != "nil"
                    params << ":#{el}"
                else
                    params << "nil"
                end
            end
            code_highlight = %(CE.hitline(#{params.join(",")}))
        end
        @code_decorate = code_highlight + ";" + @code_decorate
    else
        @code_decorate = %(CE.ch(@fg, @bg, @tx))
    end
end

# -----------
# top level
# -----------
require "optparse"
@opt = OptionParser.new

@opt.on("-s",     "--symbol-list",   @explain_s)      { display_symbol_list }
@opt.on("-l",     "--index-list",    @explain_l)      { display_color_index }
@opt.on("-f val", "--fg val",        @explain_f)      { |val| @fg = val }
@opt.on("-b val", "--bg val",        @explain_b)      { |val| @bg = val }
@opt.on("-t val", "--tx val",        @explain_t)      { |val| @tx = val }
@opt.on("-p val", "--pickup val",    @explain_p)      { |val| @pickups << val }
@opt.on("-H",     "--highlight val", @explain_H)      { |val| @highlight = val}
@opt.on("-w",     "--watch",         @explain_w)      { @is_watch     = true  }
@opt.on("-n",                        @explain_n)      { @last_lb      = false }
@opt.on("-e",                        @explain_e)      { @enable_lf    = true  }
@opt.on("--stripe",                  @explain_stripe) { @is_stripe    = true  }
@opt.on("-c", "--clean",             @explain_c)      { @enable_clean = true  }
@opt.on("-v",                        @explain_v)      { version }
@opt.on("-h",     "--help",          @explain_h)      { usage }

@opt.on("--symbol_list", @explain_s + " - [compatibility]" ) { display_symbol_list }
@opt.on("--index_list", @explain_l  + " - [compatibility]") { display_color_index }

@opt.banner = <<EOS
Usage:
#{@explain_usage}
Options:
EOS

# has stdin?
has_stdin = select([STDIN], [], [], 0) != nil || FileTest.pipe?(STDIN)

# argv error
if !has_stdin && ARGV.size == 0
    puts @opt.help
end

require_color_echo_get
Version = CE::VERSION

# parse options and set the decorate code that execute by eval
parse_options

if @enable_clean
    CE.enableclean
end

if @is_watch
    # Interactive mode
    @exit_words = ["quit", "exit", "bye"]
    output_interactive
else
    if has_stdin
        begin
            target = STDIN.read
        rescue Interrupt
            puts $/ + %(No STDIN, Try to use -w option if you need Interactive mode.)
        end

        if ARGV.size > 0
            print target
            argv  = ARGV.join(" ")
            argv += $/ if @last_lb
            output(argv)
        end
    else
        target  = ARGV.join(" ")
        target += $/ if @last_lb
    end

    if @enable_lf
        target.gsub!("\\r\\n", $/)
        target.gsub!("\\n", $/)
        target.gsub!("\\r", $/)
    end

    output(target)
end
